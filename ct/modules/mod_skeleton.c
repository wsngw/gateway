/**
 * @brief Gateway Module Skeleton
 *
 * @file
 * @author Makui (2010-11-19)
 *
 * @addtogroup GW_MOD_SKELTON Gateway Module Skeleton
 * @{
 */
#include <module.h>
#include <dotconf/dotconf.h>

#define SKEL_SERVICE	1

/* module skeleton config information */
typedef struct __tag_skel_config
{
	bstring ip_address;
	int32_t port;
}skel_conf_t;

static gw_mod_t mod_skeleton;
static gw_mod_data_t skel_data;
static gw_svc_t skel_svc;
static gw_msgq_t *skel_msgq;
static gw_thread_t skel_thread = NULL;
static skel_conf_t skel_conf;

bool_t init(gw_t *gw, gw_dlib_t lib);
bool_t cleanup(gw_t *gw);
json_object *serialize(gw_t *gw);
static DOTCONF_CB(default_callback);

static const configoption_t options[] = {
	{"PORT", ARG_INT, default_callback, NULL, 0},
	{"", ARG_NAME, default_callback, NULL, 0},
	LAST_OPTION
};

static int32_t skel_config(int8_t *path_filename)
{
	configfile_t *configfile;

	if (path_filename == NULL) {
		printf("error: NULL input\n");
		return 1;
	}
	configfile = dotconf_create(path_filename,
				    options, NULL, CASE_INSENSITIVE);
	if (!configfile) {
		fprintf(stderr, "Error creating configfile\n");
		return 1;
	}

	if (dotconf_command_loop(configfile) == 0) {
		fprintf(stderr, "Error parsing config file %s\n",configfile->filename);
		return 1;
	}

	dotconf_cleanup(configfile);

	return 0;
}

static int32_t skel_config_cleanup(void)
{
	int32_t ret;
	ret = bdestroy(skel_conf.ip_address);
	return ret;
}

DOTCONF_CB(default_callback)
{
	int32_t i, arg_count;
	bstring command;
	bstring tmpcmd;
	int8_t *ret = NULL;

	gw_debug_print("default_callback handler called for \"%s\". Got %d args\n", cmd->name,
	       cmd->arg_count);
	for (i = 0; i < cmd->arg_count; i++)
		gw_debug_print("\tArg #%d: %s\n", i, cmd->data.list[i]);

	command = bfromcstr(cmd->name);
	arg_count = cmd->arg_count;
	tmpcmd = bfromcstr("ip_address");
	if ( bstricmp(command, tmpcmd) == 0 ) {
		skel_conf.ip_address = bfromcstr(cmd->data.list[0]);
		//gw_debug_print("the ip address is %s\n", skel_conf.ip_address->data);
		ret = (int8_t *)skel_conf.ip_address->data;
	}

	bassigncstr(tmpcmd, "port");
	if ( bstricmp(command, tmpcmd) == 0 )
	{
		skel_conf.port = cmd->data.value;
		//printf("the port is set to %d\n", skel_conf.port);
		ret = (int8_t *)&skel_conf.port;
	}
	bdestroy(command);
	bdestroy(tmpcmd);
	return ret;
}

void *skel_svc_handler(void *args)
{
	gw_msg_t *msg;
	bool_t quit = FALSE;

	while (!quit && ((msg = gw_msg_recv(skel_msgq)) != NULL))
	{
		switch (msg->type)
		{
		case GW_MSG_SYSTEM_QUIT:
			quit = TRUE;
			break;
		default:
			gw_log_print(GW_LOG_LEVEL_WARNING, "unknown message type %u received by service %u, module %s\n", \
					msg->type, skel_svc.id, mod_skeleton.name);
			break;
		}
		gw_msg_free(msg);
	}

	return NULL;
}

/**
 * @brief Initialize this module.
 *
 * Call this function when loading this module.
 *
 * @param gw	pointer to gateway context
 * @param lib	pointer to dynamic library generated by this module
 *
 * @return TRUE on success, FALSE on failure
 */
bool_t init(gw_t *gw, gw_dlib_t lib)
{
	bool_t ret = TRUE;

	/* initialize module data */
	memset(&skel_data, 0, sizeof(skel_data));

	/* read config infromation */
	skel_config("/etc/gw/modules/skel.conf");

	/* initialize module structure */
	memset(&mod_skeleton, 0, sizeof(mod_skeleton));
	mod_skeleton.name = "mod_skeleton";
	mod_skeleton.desc = "mod description";
	mod_skeleton.vendor = "WSN";
	mod_skeleton.modver.major = 1;
	mod_skeleton.modver.minor = 0;
	mod_skeleton.sysver.major = 1;
	mod_skeleton.sysver.minor = 0;
	mod_skeleton.init = init;
	mod_skeleton.cleanup = cleanup;
	mod_skeleton.serialize = serialize;
	mod_skeleton.lib = lib;
	mod_skeleton.data = &skel_data;
	mod_skeleton.lock = gw_mutex_create();
	INIT_LIST_HEAD(&mod_skeleton.services);

	skel_msgq = gw_msgq_create();
	memset(&skel_svc, 0, sizeof(skel_svc));
	skel_svc.id = SKEL_SERVICE;
	skel_svc.name = "skel_service";
	skel_svc.mod = &mod_skeleton;
	skel_svc.mq = skel_msgq;

	skel_thread = gw_thread_create(skel_svc_handler, NULL);

	//TODO: initialize another stuff
	if (mod_skeleton.lock != NULL)
	{
		ret = mod_register(gw, &mod_skeleton);
		if (ret)
		{
			ret = mod_register_service(gw, &mod_skeleton, &skel_svc);
			if (ret != TRUE)
			{
				mod_unregister(gw, &mod_skeleton);
				gw_mutex_destroy(mod_skeleton.lock);
				gw_log_print(GW_LOG_LEVEL_ERROR, "module %s initialization failed\n", mod_skeleton.name);
			}
			else
			{
				gw_log_print(GW_LOG_LEVEL_INFO, "module %s initialized\n", mod_skeleton.name);
			}
		}
	}

	return ret;
}

/**
 * @brief Do the cleanup for this module.
 *
 * Call this function when unloading this module.
 *
 * @param gw pointer to gateway context
 *
 * @return TRUE on success, FALSE on failure
 */
bool_t cleanup(gw_t *gw)
{
	//TODO: cleanup module stuff
	gw_msg_t *msg;

	msg = gw_msg_alloc();
	msg->type = GW_MSG_SYSTEM_QUIT;
	msg->dstsvc = skel_svc.id;
	msg->srcsvc = skel_svc.id;
	gw_msg_send(gw, msg);

	gw_debug_print("before gw_thread_wait\n");
	gw_thread_wait(skel_thread);
	gw_debug_print("after gw_thread_wait\n");

	mod_unregister_service(gw, &mod_skeleton, &skel_svc);
	mod_unregister(gw, &mod_skeleton);

	gw_msgq_destroy(skel_msgq);
	gw_mutex_destroy(mod_skeleton.lock);

	skel_config_cleanup();

	return TRUE;
}

/**
 * @brief Output status information of this module.
 *
 * @param gw	pointer to gateway context
 * @param buf	pointer to output buffer
 *
 * @return TRUE on success, FALSE on failure
 */
json_object *serialize(gw_t *gw)
{
	json_object *my_object = NULL;

	return my_object;
}

/**
 * @}
 */
